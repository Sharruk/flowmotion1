ğŸ§  FIRST: How Your Widget Works NOW

From your search, this is important:

#widget-countdown
.countdown
updateWidgetCountdown()
setInterval(updateWidgetCountdown, 60000);


This means:

ğŸ‘‰ Your widget already uses JavaScript timer
ğŸ‘‰ It calculates time on the browser side
ğŸ‘‰ It is NOT using backend API

So:

If time is wrong â†’ JavaScript logic is wrong
If it shows 28 always â†’ starting value is wrong

âœ… STEP 1 â€” Find the Widget HTML File

From your result:

<div id="widget-countdown" class="countdown" data-time="{{ habit.


So open that file.

In Replit / VS Code:

Press:

Ctrl + Shift + F


Search exactly:

id="widget-countdown"


Open the file where it is.

It will be something like:

widget_mode.html
habit_detail.html
dashboard.html

âœ… STEP 2 â€” Look at This Line Carefully

You will see something like:

<div
  id="widget-countdown"
  class="countdown"
  data-time="{{ habit.remaining_days }}"
>
  28
</div>


or:

data-time="{{ habit.duration }}"


or:

data-time="28"


This data-time is the KEY.

That is where 28 comes from.

ğŸ§  Explanation

JS reads:

data-time="28"


Then it says:

ğŸ‘‰ Start countdown from 28 days

So if backend sends 28 always â†’ widget never changes.

âœ… STEP 3 â€” Find updateWidgetCountdown() Function

Search:

function updateWidgetCountdown


Open it.

Youâ€™ll see something like:

function updateWidgetCountdown() {
    const timerElement = document.getElementById('widget-countdown');
    const totalDays = parseInt(timerElement.dataset.time);

    let remaining = totalDays - daysPassed;

    timerElement.innerText = remaining;
}


(or similar)

This logic is probably wrong.

âœ… STEP 4 â€” Why It Fails

Your system probably does:

remaining = 28 - 0


Because:

âŒ daysPassed not saved
âŒ no start date used
âŒ page reload resets

So every reload â†’ back to 28

ğŸ¯ Now We Fix It Properly

We will:

âœ” Use backend date
âœ” Store start date
âœ” Calculate live difference

âœ… STEP 5 â€” Backend: Send Start Date

In your Django model (Habit):

Open:

models.py


Check if you have:

start_date = models.DateField(auto_now_add=True)


If not, add:

start_date = models.DateField(default=timezone.now)


Migrate if needed.

âœ… STEP 6 â€” Pass Date to Widget

In your view:

Find:

render(request, "...", context)


Add:

context["start_date"] = habit.start_date.isoformat()
context["duration"] = habit.duration  # or 28


Example:

return render(request, "widget.html", {
    "habit": habit,
    "start_date": habit.start_date.isoformat(),
    "duration": 28,
})

âœ… STEP 7 â€” Fix HTML

Now in widget template, change:

OLD âŒ

<div id="widget-countdown" data-time="28">


NEW âœ…

<div
  id="widget-countdown"
  data-start="{{ start_date }}"
  data-duration="{{ duration }}"
>
</div>

âœ… STEP 8 â€” Fix JavaScript

Replace updateWidgetCountdown() with this:

function updateWidgetCountdown() {
    const el = document.getElementById("widget-countdown");

    if (!el) return;

    const startDate = new Date(el.dataset.start);
    const duration = parseInt(el.dataset.duration);

    const today = new Date();

    const diffTime = today - startDate;
    const daysPassed = Math.floor(diffTime / (1000 * 60 * 60 * 24));

    let remaining = duration - daysPassed;

    if (remaining < 0) remaining = 0;

    el.innerText = remaining;
}

updateWidgetCountdown();
setInterval(updateWidgetCountdown, 60000);

âœ… STEP 9 â€” Restart Server

After all edits:

python manage.py runserver


or Replit restart.